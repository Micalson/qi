//auto generate!
static const char* antique_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec4 ocolor;\n"
"void main()\n"
"{\n"
"	gl_Position = projection_matrix * view_matrix * model_matrix * vec4(ver_attribute_position, 1.0);\n"
"}\n"
;
static const char* antique_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"void main()\n"
"{\n"
"	fragment_color = vec4(125.0/255.0, 221.0/255.0, 169.0/255.0, 0.1);\n"
"}\n"
"\n"
"//uniform float s = 0.5;\n"
"//uniform float h = 190.0f;\n"
"//uniform float v = 0.9;\n"
"//\n"
"//void main()\n"
"//{\n"
"//	float f = h / 60.0 - 3.0;\n"
"//	float p = v * (1.0 - s);\n"
"//	float q = v * (1.0 - f * s);\n"
"//	fragment_color = vec4(p, q, v, 1.0);\n"
"//}\n"
;
static const char* ball430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"uniform mat4 position_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position =  modelview_matrix * position_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"}\n"
;
static const char* ball430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"uniform vec4 color = vec4(0.0, 1.0, 0.0, 1.0);\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	else if (color_shading == 0.0) \n"
"	{\n"
"		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"		ambient_color = vec4(0.2, 0.2, 0.2, 1.0);\n"
"		diffuse_color = vec4(0.75, 0.75, 0.75, 1.0);\n"
"		specular_color *= 0.2;\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
;
static const char* clip430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"uniform float use_clip;\n"
"uniform vec3 center;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 o_color;\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	\n"
"	gl_Position = projection_matrix *  world_position;\n"
"\n"
"}\n"
;
static const char* clip430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 o_color;\n"
"uniform vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	//core_color = o_color;\n"
"	\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* cmd430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec2 ver_attribute_texcoord;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec2 tex_coord;\n"
"void main()\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position =  modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	tex_coord = ver_attribute_texcoord;\n"
"}\n"
;
static const char* cmd430_frag=
"#version 430 core\n"
"\n"
"out vec4 frag_color;\n"
"\n"
"in vec2 tex_coord;\n"
"\n"
"uniform sampler2D tex;\n"
"void main()\n"
"{	\n"
"	vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"	if(tex_coord.x < 0.0 || tex_coord.y < 0.0)\n"
"		frag_color = vec4(0.0, 0.0, 0.0, 0.0);\n"
"	else\n"
"		frag_color = color * texture(tex, tex_coord).r;\n"
"}\n"
;
static const char* color430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec4 ver_attribute_color;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec4 color;\n"
"void main()\n"
"{\n"
"	gl_Position = projection_matrix * view_matrix * model_matrix * vec4(ver_attribute_position, 1.0);\n"
"	color = ver_attribute_color;\n"
"}\n"
;
static const char* color430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec4 color;\n"
"\n"
"void main()\n"
"{\n"
"	fragment_color = color;\n"
"}\n"
;
static const char* colorpanel_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec2 ver_attribute_position;\n"
"layout(location = 1) in vec4 ver_attribute_color;\n"
"\n"
"uniform float viewport_width;\n"
"uniform float viewport_height;\n"
"uniform vec2 origin = vec2(0.0, 0.0);\n"
"\n"
"out vec4 color;\n"
"void main()\n"
"{\n"
"	vec2 viewport_rect = 2.0 * (ver_attribute_position + origin) / vec2(viewport_width, viewport_height);\n"
"	vec2 screen_pos = viewport_rect + vec2(-1.0, -1.0);\n"
"    gl_Position = vec4(screen_pos, 0.0, 1.0);\n"
"	color = ver_attribute_color;\n"
"}\n"
;
static const char* colorpanel_frag=
"#version 430 core\n"
"\n"
"out vec4 frag_color;\n"
"in vec4 color;\n"
"void main()\n"
"{	\n"
"	frag_color = color;\n"
"}\n"
;
static const char* curvature430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"layout(location = 2) in vec4 ver_attribute_color;\n"
"layout(location = 3) in float ver_attribute_curvature;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 color;\n"
"\n"
"vec4 curvature_to_color(float curvature)\n"
"{\n"
"	vec4 n_color = vec4(0.0, 0.0, 1.0, 1.0);\n"
"	vec4 p_color = vec4(1.0, 0.0, 0.0, 1.0);\n"
"	\n"
"	float max_c = 0.5;\n"
"	if(curvature <= -max_c)\n"
"		return n_color;\n"
"	else if(curvature >= max_c)\n"
"		return p_color;\n"
"	else\n"
"	{\n"
"		vec4 c1 = vec4(0.0, 1.0, 0.0, 1.0);\n"
"		vec4 c2 = n_color;\n"
"		if(curvature >= 0.0) c2 = p_color;\n"
"		\n"
"		float delta = abs(curvature) / max_c;\n"
"		return c1 * ( 1.0 - delta) + c2 * delta;\n"
"	}\n"
"}\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	\n"
"	color =  curvature_to_color(ver_attribute_curvature);\n"
"}\n"
;
static const char* curvature430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 color;\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	else if (color_shading == 0.0) \n"
"	{\n"
"		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"		ambient_color = vec4(0.2, 0.2, 0.2, 1.0);\n"
"		diffuse_color = vec4(0.75, 0.75, 0.75, 1.0);\n"
"		specular_color *= 0.2;\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* curvature430_ex_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"layout(location = 2) in float ver_attribute_curvature;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 color;\n"
"\n"
"vec4 curvature_to_color(float curvature)\n"
"{\n"
"	vec4 n_color = vec4(0.0, 1.0, 1.0, 1.0);\n"
"	vec4 p_color = vec4(1.0, 1.0, 0.0, 1.0);\n"
"	\n"
"	float max_c = 0.5;\n"
"	if(curvature <= -max_c)\n"
"		return n_color;\n"
"	else if(curvature >= max_c)\n"
"		return p_color;\n"
"	else\n"
"	{\n"
"		vec4 c1 = vec4(0.0, 1.0, 0.0, 1.0);\n"
"		vec4 c2 = n_color;\n"
"		if(curvature >= 0.0) c2 = p_color;\n"
"		\n"
"		float delta = abs(curvature) / max_c;\n"
"		return c1 * ( 1.0 - delta) + c2 * delta;\n"
"	}\n"
"}\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	\n"
"	color =  curvature_to_color(ver_attribute_curvature);\n"
"}\n"
;
static const char* curvature430_ex_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 color;\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	else if (color_shading == 0.0) \n"
"	{\n"
"		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"		ambient_color = vec4(0.2, 0.2, 0.2, 1.0);\n"
"		diffuse_color = vec4(0.75, 0.75, 0.75, 1.0);\n"
"		specular_color *= 0.2;\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* double_phong430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"layout(location = 2) in vec4 ver_attribute_color;\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 color;\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	color 			= ver_attribute_color;\n"
"}\n"
;
static const char* double_phong430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 color;\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* energycolor430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in float ver_attribute_energy_value;\n"
"layout(location = 2) in vec3 ver_attribute_normal;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 color;\n"
"\n"
"vec4 curvature_to_color(float energy)\n"
"{\n"
"	vec4 n_color = vec4(0.0, 0.0, 1.0, 1.0);\n"
"	vec4 m_color = vec4(0.0, 1.0, 0.0, 1.0);\n"
"	vec4 p_color = vec4(1.0, 0.0, 0.0, 1.0);\n"
"	\n"
"	if (energy > 1.0)\n"
"	{\n"
"		return n_color;\n"
"	}\n"
"	\n"
"	if (energy > 0.5)\n"
"	{\n"
"		energy = 2 * (energy - 0.5);\n"
"		return (1 - energy) * m_color + energy * n_color;\n"
"	}\n"
"	\n"
"	if (energy > 0.01)\n"
"	{\n"
"		energy = 2 * energy;\n"
"		return energy * m_color + (1 - energy) * p_color;\n"
"	}\n"
"	\n"
"	return p_color;\n"
"}\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"	normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	\n"
"	color = curvature_to_color(ver_attribute_energy_value);\n"
"	//color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"}\n"
;
static const char* energycolor430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 color;\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	else if (color_shading == 0.0) \n"
"	{\n"
"		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"		ambient_color = vec4(0.2, 0.2, 0.2, 1.0);\n"
"		diffuse_color = vec4(0.75, 0.75, 0.75, 1.0);\n"
"		specular_color *= 0.2;\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* erase_render430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"layout(location = 2) in vec4 ver_attribute_color;\n"
"layout(location = 3) in float ver_attribute_erase;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 color;\n"
"\n"
"flat out float alpha;\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	\n"
"	color =  ver_attribute_color ;\n"
"		\n"
"	alpha = ver_attribute_erase;\n"
"}\n"
"\n"
;
static const char* erase_render430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 color;\n"
"flat in float alpha;\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	if(alpha == 0.0)\n"
"		discard;\n"
"		\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	else if (color_shading == 0.0) \n"
"	{\n"
"		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"		ambient_color = vec4(0.2, 0.2, 0.2, 1.0);\n"
"		diffuse_color = vec4(0.75, 0.75, 0.75, 1.0);\n"
"		specular_color *= 0.2;\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* esscanning_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"layout(location = 3) in float ver_attribute_time;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"uniform float osg_SimulationTime;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 color;\n"
"out float shine;\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	\n"
"	color = vec4(0.0, 1.0, 0.0, 1.0);\n"
"	\n"
"	float slope = -10.0;\n"
"	shine = clamp((slope * (osg_SimulationTime - ver_attribute_time) + 1.0), 0.0, 1.0);\n"
"	if(shine > 0.0)\n"
"		color = vec4(0.0, 1.0, 1.0, 1.0);\n"
"	shine = 0.0;\n"
"}\n"
;
static const char* esscanning_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 color;\n"
"in float shine;\n"
"\n"
"uniform vec4 ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 600.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"\n"
"void main( void )\n"
"{	\n"
"	vec4 ambient_color 	  = ambient * color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	\n"
"	vec4 diffuse_color    = NdotL * diffuse * color;\n"
"	\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	\n"
"	vec4 specular_color   = specular * pow( RdotV, specular_power);\n"
"\n"
"	fragment_color = ambient_color + diffuse_color + specular_color + shine * vec4(1.0, 1.0, 1.0, 1.0);\n"
"}\n"
"\n"
;
static const char* feed_copy_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in float ver_attribute_flag;\n"
"\n"
"out float feedback_attribute;\n"
"\n"
"void main( void )\n"
"{		\n"
"	feedback_attribute = ver_attribute_flag;\n"
"}\n"
;
static const char* feed_delete_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in float ver_attribute_flag;\n"
"\n"
"out float feedback_attribute;\n"
"\n"
"void main( void )\n"
"{		\n"
"	float value = ver_attribute_flag;\n"
"	if(value >= 1.0)\n"
"		value += 1.0;\n"
"\n"
"	feedback_attribute = value;\n"
"}\n"
;
static const char* feed_deleteall_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in float ver_attribute_flag;\n"
"\n"
"out float feedback_attribute;\n"
"\n"
"void main( void )\n"
"{		\n"
"	feedback_attribute = ver_attribute_flag;\n"
"	if(feedback_attribute == 0.0)\n"
"		feedback_attribute = 2.0;\n"
"	else\n"
"		feedback_attribute += 1.0;\n"
"}\n"
;
static const char* feed_erase_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in float ver_attribute_flag;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"uniform mat4 viewport_matrix;\n"
"\n"
"uniform vec2 pick_xy;\n"
"uniform float pick_radius = 50.0;\n"
"\n"
"out float feedback_attribute;\n"
"\n"
"void main( void )\n"
"{		\n"
"	feedback_attribute = ver_attribute_flag;\n"
"	\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"	\n"
"	vec4 screen_position = viewport_matrix * projection_matrix *  world_position;\n"
"	vec2 xy = vec2(screen_position.x / screen_position.w, screen_position.y / screen_position.w);\n"
"	vec2 delta = pick_xy - xy;\n"
"	\n"
"	if(dot(delta, delta) <= pick_radius * pick_radius && feedback_attribute == 0.0)\n"
"	//if(pick_xy.x > 500 && pick_xy.y > 500 && feedback_attribute == 0.0)\n"
"		feedback_attribute = 1.0;\n"
"}\n"
;
static const char* feed_flip_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in float ver_attribute_flag;\n"
"\n"
"out float feedback_attribute;\n"
"\n"
"void main( void )\n"
"{		\n"
"	float value = ver_attribute_flag;\n"
"	if(value == 1.0)\n"
"		value = 0.0;\n"
"	else if(value == 0.0)\n"
"		value = 1.0;\n"
"		\n"
"	feedback_attribute = value;\n"
"}\n"
;
static const char* feed_lasso_test_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in float ver_attribute_position;\n"
"layout(location = 1) in float ver_attribute_feedback;\n"
"\n"
"out float feedback_attribute;\n"
"\n"
"void main( void )\n"
"{		\n"
"	feedback_attribute = clamp(ver_attribute_feedback + 0.01, 0.0, 1.0);\n"
"}\n"
"\n"
;
static const char* feed_multiquaderase_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in float ver_attribute_flag;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"uniform mat4 viewport_matrix;\n"
"\n"
"uniform vec2 rectx_range;\n"
"uniform vec2 recty_range;\n"
"\n"
"out float feedback_attribute;\n"
"\n"
"void main( void )\n"
"{		\n"
"	float value = ver_attribute_flag;\n"
"	\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"	\n"
"	vec4 screen_position = viewport_matrix * projection_matrix *  world_position;\n"
"	vec2 xy = vec2(screen_position.x / screen_position.w, screen_position.y / screen_position.w);\n"
"	\n"
"	if(xy.x >= rectx_range.x && xy.x <= rectx_range.y \n"
"		&& xy.y >= recty_range.x && xy.y <= recty_range.y)\n"
"		value = 1.0;\n"
"	\n"
"	feedback_attribute = value;\n"
"}\n"
;
static const char* feed_quaderase_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in float ver_attribute_flag;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"uniform mat4 viewport_matrix;\n"
"\n"
"uniform vec2 rectx_range;\n"
"uniform vec2 recty_range;\n"
"\n"
"out float feedback_attribute;\n"
"\n"
"void main( void )\n"
"{		\n"
"	float value = ver_attribute_flag;\n"
"	\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"	\n"
"	vec4 screen_position = viewport_matrix * projection_matrix *  world_position;\n"
"	vec2 xy = vec2(screen_position.x / screen_position.w, screen_position.y / screen_position.w);\n"
"	\n"
"	if(value <= 1.0)\n"
"	{\n"
"		value = 0.0;\n"
"		if(xy.x >= rectx_range.x && xy.x <= rectx_range.y \n"
"			&& xy.y >= recty_range.x && xy.y <= recty_range.y)\n"
"			value = 1.0;\n"
"	}\n"
"	\n"
"	feedback_attribute = value;\n"
"}\n"
;
static const char* feed_reserve_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in float ver_attribute_flag;\n"
"\n"
"out float feedback_attribute;\n"
"\n"
"void main( void )\n"
"{		\n"
"	feedback_attribute = ver_attribute_flag - 1.0;\n"
"	if(feedback_attribute <= 1.0)\n"
"		feedback_attribute = 0.0;\n"
"}\n"
;
static const char* feed_selectall_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in float ver_attribute_flag;\n"
"\n"
"out float feedback_attribute;\n"
"\n"
"void main( void )\n"
"{		\n"
"	float value = ver_attribute_flag;\n"
"	if(value == 0.0)\n"
"		value = 1.0;\n"
"		\n"
"	feedback_attribute = value;\n"
"}\n"
;
static const char* feed_triangle_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in float ver_attribute_flag;\n"
"layout(r32f, binding = 0) uniform image2D mask;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"uniform mat4 viewport_matrix;\n"
"\n"
"out float feedback_attribute;\n"
"\n"
"void main( void )\n"
"{		\n"
"	float value = ver_attribute_flag;\n"
"	\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"	\n"
"	vec4 screen_position = viewport_matrix * projection_matrix *  world_position;\n"
"	vec2 xy = vec2(screen_position.x / screen_position.w, screen_position.y / screen_position.w);\n"
"	\n"
"	vec4 mask_color = imageLoad(mask, ivec2(xy));\n"
"	\n"
"	if(value == 0.0 && mask_color.r == 1.0)\n"
"		value = 1.0;\n"
"	feedback_attribute = value;\n"
"}\n"
;
static const char* feedback_erase430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 3) in float ver_attribute_feedback;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"uniform mat4 viewport_matrix;\n"
"\n"
"uniform vec2 pick_xy;\n"
"uniform float pick_radius = 50.0;\n"
"\n"
"out float feedback_alpha;\n"
"out float feedback_attribute;\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"	\n"
"	vec4 screen_position = viewport_matrix * projection_matrix *  world_position;\n"
"	vec2 xy = vec2(screen_position.x / screen_position.w, screen_position.y / screen_position.w);\n"
"	vec2 delta = pick_xy - xy;\n"
"	\n"
"	feedback_alpha = ver_attribute_feedback;\n"
"	if(dot(delta, delta) <= pick_radius * pick_radius)\n"
"		feedback_alpha = 0.0;\n"
"		\n"
"	feedback_attribute = feedback_alpha; \n"
"}\n"
"\n"
;
static const char* harmonic_ball430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"uniform mat4 scale_matrix;\n"
"uniform mat4 position_matrix;\n"
"uniform vec4 ball_color;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 color;\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position =  modelview_matrix * position_matrix * scale_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	color 			= ball_color;\n"
"}\n"
;
static const char* harmonic_ball430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 color;\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	else if (color_shading == 0.0) \n"
"	{\n"
"		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"		ambient_color = vec4(0.2, 0.2, 0.2, 1.0);\n"
"		diffuse_color = vec4(0.75, 0.75, 0.75, 1.0);\n"
"		specular_color *= 0.2;\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
;
static const char* harmonic_phong430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"layout(location = 2) in float ver_harmonic_value;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 color;\n"
"\n"
"vec4 harmonic_value(float value)\n"
"{\n"
"	vec4 r = vec4(1.0, 0.0, 0.0, 1.0);\n"
"	vec4 g = vec4(0.0, 1.0, 0.0, 1.0);\n"
"	vec4 b = vec4(0.0, 0.0, 1.0, 1.0);\n"
"	\n"
"	//if(value > 0.5)\n"
"	//{\n"
"	//	float l = (value - 0.5)/0.5;\n"
"	//	return r * l + g * ( 1.0 - l);\n"
"	//}else\n"
"	//{\n"
"	//	float l = (0.5 - value)/0.5;\n"
"	//	return b * l + g * (1.0 - l);\n"
"	//}\n"
"	\n"
"	if(value > 0.6)\n"
"		return r;\n"
"	else if(value < 0.4)\n"
"		return b;\n"
"	else \n"
"		return g;\n"
"}\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	color 			= harmonic_value(ver_harmonic_value);\n"
"}\n"
;
static const char* harmonic_phong430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 color;\n"
"\n"
"uniform vec4 front_ambient = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	else if (color_shading == 0.0) \n"
"	{\n"
"		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"		ambient_color = vec4(0.2, 0.2, 0.2, 1.0);\n"
"		diffuse_color = vec4(0.75, 0.75, 0.75, 1.0);\n"
"		specular_color *= 0.2;\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* keyframe_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"uniform mat4 key_matrix;\n"
"uniform float colorid;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 color;\n"
"\n"
"vec4 gencolor(float id)\n"
"{\n"
"	float v = 4.0f;\n"
"	int value = int(id);\n"
"	int b = value%5;\n"
"	int g = (value/5)%5;\n"
"	int r = (value/25)%4;\n"
"	float cb = float(b)/v;\n"
"	float cg = float(g)/v;\n"
"	float cr = float(r)/v;\n"
"	return vec4(cr, cg, cb, 1.0);\n"
"}\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix * key_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	if(colorid == 0.0)\n"
"		color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"	else\n"
"		color = gencolor(colorid);\n"
"}\n"
;
static const char* keyframe_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 color;\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	else if (color_shading == 0.0) \n"
"	{\n"
"		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"		ambient_color = vec4(0.2, 0.2, 0.2, 1.0);\n"
"		diffuse_color = vec4(0.75, 0.75, 0.75, 1.0);\n"
"		specular_color *= 0.2;\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* lasso_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"layout(location = 2) in float ver_attribute_flag;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"flat out float flag;\n"
"\n"
"void main( void )\n"
"{	\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	flag 			= ver_attribute_flag;\n"
"}\n"
;
static const char* lasso_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"flat in float flag;\n"
"uniform vec4 color = vec4(0.0, 1.0, 0.0, 1.0);\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"\n"
"vec4 flag2color(float flag)\n"
"{\n"
"	if(flag >= 2.0)\n"
"		return vec4(0.0, 0.0, 1.0, 1.0);\n"
"	else if(flag >= 1.0)\n"
"		return vec4(1.0, 0.0, 0.0, 1.0);\n"
"	else\n"
"		return color;\n"
"}\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = flag2color(flag);\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* lasso_render_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"layout(location = 2) in float ver_attribute_flag;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"flat out float flag;\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	flag = ver_attribute_flag;\n"
"}\n"
;
static const char* lasso_render_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"flat in float flag;\n"
"uniform vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"\n"
"vec4 flagtocolor(float flag)\n"
"{\n"
"	if(flag == 0.0)\n"
"		return vec4(1.0, 1.0, 1.0, 1.0);\n"
"	else if(flag == 1.0)\n"
"		return vec4(0.0, 1.0, 0.0, 1.0);\n"
"	else if(flag == 2.0)\n"
"		return vec4(1.0, 0.0, 0.0, 1.0);\n"
"	return vec4(0.0, 0.0, 1.0, 1.0);\n"
"}\n"
"\n"
"vec4 colortest(float flag)\n"
"{\n"
"	return vec4(flag);\n"
"}\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = colortest(flag);\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* layer_vert=
"#version 430 core\n"
"layout(location = 0) in vec2 ver_attribute_position;\n"
"\n"
"void main()\n"
"{\n"
"    gl_Position = vec4(norm_screen_pos, 0.0, 1.0);\n"
"}\n"
;
static const char* layer_frag=
"#version 430 core\n"
"\n"
"layout(r32f, binding = 0) uniform image2D mask;\n"
"\n"
"out vec4 frag_color;\n"
"\n"
"in vec2 screen_pos;\n"
"uniform vec4 color = vec4(1.0, 1.0, 0.0, 1.0);\n"
"void main()\n"
"{	\n"
"	imageStore(mask, ivec2(screen_pos), vec4(1.0, 0.0, 0.0, 0.0));\n"
"	//frag_color = color;\n"
"}\n"
"\n"
"//out vec4 fragment_color;\n"
"//uniform float s = 0.5;\n"
"//uniform float h = 190.0f;\n"
"//uniform float v = 0.9;\n"
"//\n"
"//void main()\n"
"//{\n"
"//	float f = h / 60.0 - 3.0;\n"
"//	float p = v * (1.0 - s);\n"
"//	float q = v * (1.0 - f * s);\n"
"//	fragment_color = vec4(p, q, v, 1.0);\n"
"//}\n"
;
static const char* multipick430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"void main( void )\n"
"{\n"
"    gl_Position = projection_matrix * view_matrix * model_matrix * vec4(ver_attribute_position, 1.0);\n"
"}\n"
"\n"
;
static const char* multipick430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"uniform uint mesh_id = 0;  \n"
"\n"
"void main( void )\n"
"{				\n"
"	uint primitive_id = gl_PrimitiveID + 1;\n"
"	\n"
"	uint a = primitive_id%256;\n"
"	uint b = (primitive_id/(1<<8))%256;\n"
"	uint g = (primitive_id/(1<<16))%256;\n"
"	uint r = mesh_id%256;\n"
"	vec4 color = vec4(float(r)/255.0, float(g)/255.0, float(b)/255.0, float(a)/255.0);\n"
"	\n"
"	fragment_color = color;\n"
"}\n"
"\n"
;
static const char* odometer430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"uniform mat4 align_matrix;\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix * align_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"}\n"
;
static const char* odometer430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"uniform vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* phong430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"layout(location = 2) in vec4 ver_attribute_color;\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 color;\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	color 			= ver_attribute_color;\n"
"}\n"
;
static const char* phong430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 color;\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	else if (color_shading == 0.0) \n"
"	{\n"
"		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"		ambient_color = vec4(0.2, 0.2, 0.2, 1.0);\n"
"		diffuse_color = vec4(0.75, 0.75, 0.75, 1.0);\n"
"		specular_color *= 0.2;\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* point_segment430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"layout(location = 2) in float ver_attribute_flag;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 color;\n"
"\n"
"vec4 flag2color(float value)\n"
"{\n"
"	if(value == 1.0)\n"
"		return vec4(0.0, 1.0, 0.0, 1.0);\n"
"	else if(value == 2.0)\n"
"		return vec4(1.0, 0.0, 0.0, 1.0);\n"
"	else if(value == 3.0)\n"
"		return vec4(1.0, 1.0, 0.0, 1.0);\n"
"	else if(value == 4.0)\n"
"		return vec4(1.0, 0.0, 1.0, 1.0);\n"
"	else if(value == 5.0)\n"
"		return vec4(0.0, 0.0, 1.0, 1.0);\n"
"	else if(value == 6.0)\n"
"		return vec4(0.0, 1.0, 0.5, 1.0);\n"
"	else if(value == 7.0)\n"
"		return vec4(1.0, 0.0, 0.4, 1.0);\n"
"	else if(value == 8.0)\n"
"		return vec4(0.4, 0.4, 0.7, 1.0);\n"
"	else if(value == 9.0)\n"
"		return vec4(1.0, 0.9, 0.3, 1.0);\n"
"	else if(value == 10.0)\n"
"		return vec4(0.4, 0.8, 1.0, 1.0);	\n"
"	return vec4(1.0, 1.0, 1.0, 1.0);\n"
"}\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	\n"
"	color = flag2color(ver_attribute_flag);\n"
"}\n"
;
static const char* point_segment430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 color;\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* pointphong430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"}\n"
;
static const char* pointphong430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"uniform vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	else if (color_shading == 0.0) \n"
"	{\n"
"		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"		ambient_color = vec4(0.2, 0.2, 0.2, 1.0);\n"
"		diffuse_color = vec4(0.75, 0.75, 0.75, 1.0);\n"
"		specular_color *= 0.2;\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* purecolor430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"out vec4 ocolor;\n"
"void main()\n"
"{\n"
"	gl_Position = projection_matrix * view_matrix * model_matrix * vec4(ver_attribute_position, 1.0);\n"
"}\n"
;
static const char* purecolor430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"uniform vec4 color;\n"
"\n"
"void main()\n"
"{\n"
"	fragment_color = color;\n"
"}\n"
;
static const char* robot_background_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec2 ver_attribute_position;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = vec4(ver_attribute_position, -0.9990, 1.0);\n"
"}\n"
;
static const char* robot_background_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"uniform vec4 color;\n"
"void main()\n"
"{\n"
"	fragment_color = color;\n"
"}\n"
"\n"
;
static const char* robot_shader_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"void main()\n"
"{\n"
"	gl_Position = projection_matrix * view_matrix * model_matrix * vec4(ver_attribute_position, 1.0);\n"
"}\n"
;
static const char* robot_shader_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"uniform vec4 color = vec4(125.0/255.0, 221.0/255.0, 169.0/255.0, 0.1);\n"
"void main()\n"
"{\n"
"	fragment_color = color;\n"
"}\n"
"\n"
;
static const char* screendividingrule2d_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec2 ver_attribute_position;\n"
"\n"
"uniform float viewport_width;\n"
"uniform float viewport_height;\n"
"uniform vec2 origin;\n"
"uniform float width;\n"
"uniform float height;\n"
"\n"
"out float d;\n"
"void main()\n"
"{\n"
"	vec2 screen_pos = origin + ver_attribute_position * vec2(width, height);\n"
"	vec2 normalize_pos = 2.0 * (screen_pos) / vec2(viewport_width, viewport_height) + vec2(-1.0, -1.0);\n"
"    gl_Position = vec4(normalize_pos, 0.0, 1.0);\n"
"	d = ver_attribute_position.y;\n"
"}\n"
;
static const char* screendividingrule2d_frag=
"#version 430 core\n"
"\n"
"out vec4 frag_color;\n"
"uniform vec4 upper_color;\n"
"uniform vec4 lower_color;\n"
"uniform float divide;\n"
"\n"
"in float d;\n"
"void main()\n"
"{	\n"
"	if(d >= divide)\n"
"		frag_color = upper_color;\n"
"	else\n"
"		frag_color = lower_color;\n"
"}\n"
;
static const char* screenlinetext_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec2 ver_attribute_position;\n"
"layout(location = 1) in vec2 ver_attribute_texcoord;\n"
"layout(location = 2) in vec4 ver_attribute_color;\n"
"\n"
"uniform float viewport_width;\n"
"uniform float viewport_height;\n"
"uniform vec2 origin;\n"
"uniform float width;\n"
"uniform float height;\n"
"\n"
"out vec2 texcoord;\n"
"out vec4 color;\n"
"void main()\n"
"{\n"
"	vec2 screen_pos = origin + ver_attribute_position * vec2(width, height);\n"
"	vec2 normalize_pos = 2.0 * (screen_pos) / vec2(viewport_width, viewport_height) + vec2(-1.0, -1.0);\n"
"    gl_Position = vec4(normalize_pos, 0.0, 1.0);\n"
"	texcoord = ver_attribute_texcoord;\n"
"	color = ver_attribute_color;\n"
"}\n"
;
static const char* screenlinetext_frag=
"#version 430 core\n"
"\n"
"out vec4 frag_color;\n"
"\n"
"in vec2 texcoord;\n"
"in vec4 color;\n"
"uniform sampler2D font;\n"
"\n"
"void main()\n"
"{	\n"
"	float r = texture2D(font, texcoord).r;\n"
"	frag_color = color * r;\n"
"}\n"
;
static const char* screenquad2d_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec2 ver_attribute_position;\n"
"\n"
"uniform float viewport_width;\n"
"uniform float viewport_height;\n"
"uniform vec2 origin;\n"
"uniform float width;\n"
"uniform float height;\n"
"\n"
"void main()\n"
"{\n"
"	vec2 screen_pos = origin + ver_attribute_position * vec2(width, height);\n"
"	vec2 normalize_pos = 2.0 * (screen_pos) / vec2(viewport_width, viewport_height) + vec2(-1.0, -1.0);\n"
"    gl_Position = vec4(normalize_pos, 0.0, 1.0);\n"
"}\n"
;
static const char* screenquad2d_frag=
"#version 430 core\n"
"\n"
"out vec4 frag_color;\n"
"uniform vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n"
"void main()\n"
"{	\n"
"	frag_color = color;\n"
"}\n"
;
static const char* screensingletext_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec2 ver_attribute_position;\n"
"layout(location = 1) in vec2 ver_attribute_texcoord;\n"
"\n"
"uniform float viewport_width;\n"
"uniform float viewport_height;\n"
"uniform vec2 origin;\n"
"uniform float width;\n"
"uniform float height;\n"
"\n"
"out vec2 texcoord;\n"
"void main()\n"
"{\n"
"	vec2 screen_pos = origin + ver_attribute_position * vec2(width, height);\n"
"	vec2 normalize_pos = 2.0 * (screen_pos) / vec2(viewport_width, viewport_height) + vec2(-1.0, -1.0);\n"
"    gl_Position = vec4(normalize_pos, 0.0, 1.0);\n"
"	texcoord = ver_attribute_texcoord;\n"
"}\n"
;
static const char* screensingletext_frag=
"#version 430 core\n"
"\n"
"out vec4 frag_color;\n"
"\n"
"in vec2 texcoord;\n"
"uniform vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"uniform sampler2D font;\n"
"\n"
"void main()\n"
"{	\n"
"	float r = texture2D(font, texcoord).r;\n"
"	frag_color = color * r;\n"
"	//frag_color = vec4(texcoord, 0.0, 1.0);\n"
"}\n"
;
static const char* screentext_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec2 ver_attribute_position;\n"
"\n"
"uniform float font_size;\n"
"uniform float viewport_width;\n"
"uniform float viewport_height;\n"
"uniform vec2 origin = vec2(0.0, 0.0);\n"
"uniform vec2 offset = vec2(0.0, 0.0);\n"
"\n"
"void main()\n"
"{\n"
"	float factor = font_size;\n"
"	vec2 viewport_rect = 2.0 * (ver_attribute_position + offset) * vec2(factor, factor) / vec2(viewport_width, viewport_height);\n"
"	vec2 screen_pos = viewport_rect + vec2(-1.0, -1.0);\n"
"    gl_Position = vec4(screen_pos, 0.0, 1.0);\n"
"}\n"
;
static const char* screentext_frag=
"#version 430 core\n"
"\n"
"out vec4 frag_color;\n"
"\n"
"void main()\n"
"{	\n"
"	frag_color = vec4(1.0, 0.0, 0.0, 1.0);\n"
"}\n"
;
static const char* seg430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"layout(location = 2) in float ver_attribute;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"uniform uint branch;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 color;\n"
"\n"
"vec4 visual_curvature(float value)\n"
"{\n"
"	if(value < -1.0)\n"
"		return vec4(1.0, 0.0, 0.0, 1.0);\n"
"	else if(value > 1.0)\n"
"		return vec4(0.0, 0.0, 1.0, 1.0);\n"
"	return vec4(0.0, 1.0, 0.0f, 1.0);\n"
"}\n"
"\n"
"vec4 visual_distance(float value)\n"
"{\n"
"	return vec4(0.0, abs(value)/15.0, 0.0f, 1.0);\n"
"}\n"
"\n"
"vec4 visual_color(float value)\n"
"{\n"
"	if(branch == 0)\n"
"		return vec4(1.0, 1.0, 1.0, 1.0);\n"
"	else if(branch == 1)\n"
"		return visual_curvature(value);\n"
"	else if(branch == 2)\n"
"		return visual_distance(value);\n"
"	else\n"
"		return vec4(1.0, 1.0, 1.0, 1.0);\n"
"}\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	\n"
"	color = visual_color(ver_attribute);\n"
"}\n"
;
static const char* seg430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 color;\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	else if (color_shading == 0.0) \n"
"	{\n"
"		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"		ambient_color = vec4(0.2, 0.2, 0.2, 1.0);\n"
"		diffuse_color = vec4(0.75, 0.75, 0.75, 1.0);\n"
"		specular_color *= 0.2;\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* testicp430_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"uniform mat4 align_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix * align_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"}\n"
;
static const char* testicp430_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"uniform vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"uniform float color_shading = 1.0;\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	if(!gl_FrontFacing)\n"
"	{\n"
"		fnormal.z  = - fnormal.z;\n"
"		ambient_color = back_ambient;\n"
"		diffuse_color = back_diffuse;\n"
"		specular_color = vec4(0.0, 0.0, 0.0, 1.0);\n"
"	    \n"
"		core_color = vec4(0.6, 0.6, 0.6, 1.0);\n"
"	}\n"
"	else if (color_shading == 0.0) \n"
"	{\n"
"		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"		ambient_color = vec4(0.2, 0.2, 0.2, 1.0);\n"
"		diffuse_color = vec4(0.75, 0.75, 0.75, 1.0);\n"
"		specular_color *= 0.2;\n"
"	}\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* testnormal_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"\n"
"out vec3 position;\n"
"out vec3 normal;\n"
"void main()\n"
"{\n"
"	position = ver_attribute_position;\n"
"	normal = ver_attribute_normal;\n"
"}\n"
;
static const char* testnormal_geom=
"#version 430 core\n"
"layout(points) in;\n"
"layout(line_strip, max_vertices = 2) out;\n"
"\n"
"in vec3 position;\n"
"in vec3 normal;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"\n"
"void main()\n"
"{\n"
"	mat4 m = projection_matrix * view_matrix * model_matrix;\n"
"	\n"
"	gl_Position = m * vec4(position, 1.0);\n"
"	EmitVertex();\n"
"	gl_Position = m * vec4(position + vec3(100.0, 0.0, 0.0), 1.0);\n"
"	EmitVertex();\n"
"	EndPrimitive();\n"
"}\n"
;
static const char* testnormal_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"void main()\n"
"{\n"
"	fragment_color = vec4(1.0, 0.0, 0.0, 1.0);\n"
"}\n"
;
static const char* trimeshesscanning_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"uniform float osg_SimulationTime;\n"
"uniform mat4 icp_matrix;\n"
"uniform float time;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"out vec4 color;\n"
"out float shine;\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix * icp_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix *  world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"	\n"
"	color = vec4(0.0, 1.0, 0.0, 1.0);\n"
"	\n"
"	float slope = -10.0;\n"
"	shine = clamp((slope * (osg_SimulationTime - time) + 1.0), 0.0, 1.0);\n"
"}\n"
;
static const char* trimeshesscanning_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"in vec4 color;\n"
"in float shine;\n"
"\n"
"uniform vec4 ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 600.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"\n"
"void main( void )\n"
"{	\n"
"	vec4 ambient_color 	  = ambient * color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	\n"
"	vec4 diffuse_color    = NdotL * diffuse * color;\n"
"	\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	\n"
"	vec4 specular_color   = specular * pow( RdotV, specular_power);\n"
"\n"
"	fragment_color = ambient_color + diffuse_color + specular_color + shine * vec4(1.0, 1.0, 1.0, 1.0);\n"
"}\n"
"\n"
;
static const char* trimeshicptest_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec3 ver_attribute_position;\n"
"layout(location = 1) in vec3 ver_attribute_normal;\n"
"\n"
"uniform mat4 model_matrix;\n"
"uniform mat4 view_matrix;\n"
"uniform mat4 projection_matrix;\n"
"uniform mat4 icp_matrix;\n"
"\n"
"out vec3 view_direction;\n"
"out vec3 normal;\n"
"\n"
"void main( void )\n"
"{\n"
"	mat4 modelview_matrix = view_matrix * model_matrix * icp_matrix;\n"
"	vec4 world_position = modelview_matrix * vec4(ver_attribute_position, 1.0);\n"
"    gl_Position = projection_matrix * world_position;\n"
"	\n"
"	view_direction  = normalize(vec3(-world_position));\n"
"    normal          = mat3(modelview_matrix) * ver_attribute_normal;\n"
"}\n"
;
static const char* trimeshicptest_frag=
"#version 430 core\n"
"\n"
"out vec4 fragment_color;\n"
"\n"
"in vec3 view_direction;\n"
"in vec3 normal;\n"
"uniform vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"\n"
"uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
"uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
"uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
"uniform float specular_power = 128.0;\n"
"uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
"\n"
"void main( void )\n"
"{\n"
"	vec4 core_color = color;\n"
"	vec3 flight_direction = normalize(light_direction);\n"
"	vec3 fnormal 		  =	normalize(normal);\n"
"	vec4 ambient_color 	  = front_ambient;\n"
"	vec4 diffuse_color    = front_diffuse;\n"
"	vec4 specular_color   = specular;\n"
"	\n"
"	float NdotL 		  = dot(fnormal, flight_direction);\n"
"	ambient_color 		  = ambient_color * core_color;\n"
"	diffuse_color         = diffuse_color * core_color;\n"
"	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - flight_direction);\n"
"	vec3 fview_direction  = normalize(view_direction);\n"
"	float RdotV           = max(0.0, dot(freflection, fview_direction)); \n"
"	vec4 total_diffuse    = NdotL * diffuse_color;\n"
"	vec4 total_specular   = specular_color * pow( RdotV, 70.0);\n"
"	core_color = ambient_color + total_diffuse + total_specular;\n"
"	fragment_color = vec4(core_color.rgb, color.a);\n"
"}\n"
"\n"
;
static const char* viewport_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec2 ver_attribute_position;\n"
"\n"
"uniform float viewport_width;\n"
"uniform float viewport_height;\n"
"uniform vec2 origin = vec2(0.0, 0.0);\n"
"\n"
"void main()\n"
"{\n"
"	vec2 viewport_rect = 2.0 * (ver_attribute_position) / vec2(viewport_width, viewport_height);\n"
"	vec2 screen_pos = viewport_rect + vec2(-1.0, -1.0);\n"
"    gl_Position = vec4(screen_pos, 0.0, 1.0);\n"
"}\n"
;
static const char* viewport_frag=
"#version 430 core\n"
"\n"
"out vec4 frag_color;\n"
"uniform vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n"
"void main()\n"
"{	\n"
"	frag_color = color;\n"
"}\n"
;
static const char* viewporttexture_vert=
"#version 430 core\n"
"\n"
"layout(location = 0) in vec2 ver_attribute_position;\n"
"//layout(r32f, binding = 0) uniform image2D mask;\n"
"\n"
"uniform float viewport_width;\n"
"uniform float viewport_height;\n"
"uniform vec2 origin = vec2(0.0, 0.0);\n"
"out vec2 screen_pos;\n"
"void main()\n"
"{\n"
"	screen_pos = ver_attribute_position;\n"
"	//imageStore(mask, ivec2(0, 0), vec4(1.0, 0.0, 0.0, 0.0));\n"
"	vec2 viewport_rect = 2.0 * (ver_attribute_position) / vec2(viewport_width, viewport_height);\n"
"	vec2 norm_screen_pos = viewport_rect + vec2(-1.0, -1.0);\n"
"    gl_Position = vec4(norm_screen_pos, 0.0, 1.0);\n"
"}\n"
;
static const char* viewporttexture_frag=
"#version 430 core\n"
"layout(r32f, binding = 0) uniform image2D mask;\n"
"\n"
"out vec4 frag_color;\n"
"\n"
"in vec2 screen_pos;\n"
"uniform vec4 color = vec4(1.0, 1.0, 0.0, 1.0);\n"
"void main()\n"
"{	\n"
"	imageStore(mask, ivec2(screen_pos), vec4(1.0, 0.0, 0.0, 0.0));\n"
"	//frag_color = color;\n"
"}\n"
;
